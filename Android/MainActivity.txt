package com.example.mdp_group15_2021s2

import android.Manifest
import android.app.Activity
import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothDevice
import android.content.*
import android.content.pm.PackageManager
import android.graphics.Color
import android.os.Bundle
import android.os.CountDownTimer
import android.os.Handler
import android.os.Message
import android.text.method.ScrollingMovementMethod
import android.util.Log
import android.view.*
import android.widget.*
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import com.example.mdp_group15_2021s2.entity.MessageLog
import com.example.mdp_group15_2021s2.service.BluetoothService
import kotlinx.android.synthetic.main.activity_main.*
import com.example.mdp_group15_2021s2.entity.Device
import com.example.mdp_group15_2021s2.entity.Message.Companion.MESSAGE_RECEIVER
import com.example.mdp_group15_2021s2.entity.Message.Companion.MESSAGE_SENDER
import com.example.mdp_group15_2021s2.entity.Protocol
import com.example.mdp_group15_2021s2.entity.Store
import com.example.mdp_group15_2021s2.util.Cmd
import com.example.mdp_group15_2021s2.util.MapDrawer
import com.example.mdp_group15_2021s2.util.Parser
import java.io.*
import java.lang.ref.WeakReference
import java.text.DecimalFormat


class MainActivity : AppCompatActivity() {
    private lateinit var bluetoothAdapter: BluetoothAdapter
    private var connectionThread: BluetoothService? = null
    private lateinit var connectedDevice: BluetoothDevice
    private lateinit var listviewDevices: ListView
    private val messageLog = MessageLog()
    private var disconnectState = true
    private var startModeState = false
    private var fastestPathModeState = false
    private var autoModeState = true
    private val deviceList = ArrayList<Device>()
    private lateinit var timer: CountDownTimer
    private lateinit var inflater: LayoutInflater
    private var buttonScan: Button? = null
    private var textboxString1: EditText? = null
    private var textboxString2: EditText? = null
    private var textboxSendMessage: EditText? = null
    private var scrollView: ScrollView? = null
    private var messageLogView: TextView? = null
    private var currentTime = System.currentTimeMillis()
    private lateinit var sensorOrientation: OrientationEventListener
    val parser = Parser()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        inflater = LayoutInflater.from(this)
        setContentView(R.layout.activity_main)


        if (ContextCompat.checkSelfPermission(applicationContext, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED)
            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.ACCESS_COARSE_LOCATION), 1)

        bluetoothAdapter = BluetoothAdapter.getDefaultAdapter()
        if (!bluetoothAdapter.isEnabled) {
            val enableBluetooth = Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE)
            startActivityForResult(enableBluetooth, 1)
        }
        val filter = IntentFilter().apply {
            addAction(BluetoothDevice.ACTION_FOUND)
            addAction(BluetoothDevice.ACTION_ACL_CONNECTED)
            addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED)
        }
        registerReceiver(receiver, filter)

        button_direction_left.setOnClickListener(directionLeft)
        button_direction_right.setOnClickListener(directionRight)
        button_direction_up.setOnClickListener(directionUp)
        button_refresh_phase.setOnClickListener(refreshState)
        switch_motion_control.setOnCheckedChangeListener(motionControl)
        button_set_origin.setOnClickListener(setOrigin)
        button_set_waypoint.setOnClickListener(setWayPoint)
        button_start_phase.setOnClickListener(startMode)
        toggle_mode_fastest_path.setOnCheckedChangeListener(changeModeFastestPath)
        toggle_update_auto.setOnCheckedChangeListener(changeAutoMode)
        canvas_gridmap.setOnTouchListener(setMap)
        button_reset_map.setOnClickListener(resetMap)
        sensorOrientation = object: OrientationEventListener(this) { override fun onOrientationChanged(orientation: Int) { handleRotation(orientation) } }

        // Joystick Listener
        joystickView.setOnMoveListener{ angle, _ ->
            if (angle in 46..134) {
                val xAxis = MapDrawer.Robot_X
                val yAxis = MapDrawer.Robot_Y

                MapDrawer.moveUp()
                if (!(xAxis == MapDrawer.Robot_X && yAxis == MapDrawer.Robot_Y)) sendString(commandWrap(Cmd.DIRECTION_UP))
                canvas_gridmap.invalidate()
                updateRobotPositionLabel()
            } else if ((angle in 1..45) || (angle in 316..359)) {
                sendString(commandWrap(Cmd.DIRECTION_RIGHT))
                MapDrawer.moveRight()
                canvas_gridmap.invalidate()
                updateRobotPositionLabel()
            } else if (angle in 135..254) {
                sendString(commandWrap(Cmd.DIRECTION_LEFT))
                MapDrawer.moveLeft()
                canvas_gridmap.invalidate()
                updateRobotPositionLabel()
            }
        }
    }
    private val receiver = object: BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            val action = intent.action
            val device: BluetoothDevice?
            val getCurrentConnection: String?
            Log.i(TAG, action)
            when (action) {
                BluetoothDevice.ACTION_FOUND -> {
                    device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)
                    if (device != null){
                        Log.d(TAG, if (device.name != null) device.name else "No device name")
                        addDevice(device, if (device.name != null) device.name else " ", device.address)
                    }
                }
                BluetoothDevice.ACTION_ACL_CONNECTED -> {
                    getCurrentConnection = label_bluetooth_status.text.toString()
                    if (connectionThread != null || !disconnectState && getCurrentConnection == "Not Connected") {
                        Log.d(TAG, "Connected with a device")
                        device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)
                        connectedState(device)
                        disconnectState = false
                        disableElement(buttonScan)
                        disableElement(listviewDevices)

                        if (isPairedDevicesOnly) {
                            clearDeviceList()
                            isPairedDevicesOnly = false
                        }
                    }
                }
                BluetoothDevice.ACTION_ACL_DISCONNECTED -> {
                    getCurrentConnection = label_bluetooth_status.text.toString()
                    device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE)
                    Log.d(TAG, "Disconnected with device: ${device.name} ${device.address}")
                    if (getCurrentConnection != "Not Connected" && device.address == connectedDevice.address) {
                        connectionThread?.cancel()
                        if (!disconnectState) {
                            Log.d(TAG, "Starting Client")
                            connectionThread = BluetoothService(streamHandler)
                            connectionThread?.connectDevice(connectedDevice)
                        } else connectionThread = null
                        disconnectedState()
                    }
                }
                else -> Log.d(TAG, "Default case for receiver")
            }
        }
    }

    private fun addDevice(device: BluetoothDevice, deviceName: String, deviceHardwareAddress: String) {
        var flag = true
        run toBreak@ {
            deviceList.forEach {
                if (it.macAddr == deviceHardwareAddress && it.deviceName == deviceName) {
                    flag = false
                    return@toBreak
                }
            }
        }

        if (flag) {
            deviceList.add(Device(device, deviceName, deviceHardwareAddress))
            listviewDevices.invalidate()

            val state = listviewDevices.onSaveInstanceState()
            val adapter = DeviceAdapter(applicationContext, deviceList)
            listviewDevices.adapter = adapter
            listviewDevices.onRestoreInstanceState(state)
        }
    }

    private fun clearDeviceList() {
        deviceList.clear()
        listviewDevices.invalidate()
        val adapter = DeviceAdapter(applicationContext, deviceList)
        listviewDevices.adapter = adapter
    }
    private val streamHandler = StreamHandler(this)
    class StreamHandler(activity: MainActivity) : Handler() {
        private val ref = WeakReference(activity)
        override fun handleMessage(message: Message) {
            val activity = ref.get()
            when (message.what) {
                Protocol.MESSAGE_RECEIVE -> {
                    // Factor into various scenarios
                    val buffer = message.obj as ByteArray
                    val data = String(buffer, 0, message.arg1)
                    Log.d(TAG, "Received data : $data")
                    if (activity == null) { Log.e(TAG, "No activity object, Not continuing..."); return }
                    activity.messageLog.addMessage(MESSAGE_RECEIVER, data.trim())
                    // Split data by ;
                    val textArr = data.split(";")
                    textArr.forEach {
                        if (it.isEmpty()) return@forEach
                        activity.handleAction(it.trim()) // Handle Action
                    }

                    activity.messageLogView?.text = activity.messageLog.getLog()
                }
                Protocol.CONNECTION_ERROR -> {
                    Log.d(TAG, "Connection error with a device")
                    activity?.connectionThread?.cancel()
                    activity?.connectBluetoothDevice()
                }
                Protocol.MESSAGE_ERROR -> {
                    Log.d(TAG, "Error sending message to device")
                    activity?.transmissionFail()
                }
                else -> Log.d(TAG, "Just a default case")
            }
        }
        companion object { private const val TAG = "StreamHandler" }
    }

    override fun onDestroy() {
        super.onDestroy()
        unregisterReceiver(receiver)

        connectionThread?.cancel()
    }
    private fun connectedState(device: BluetoothDevice) {
        connectedDevice = device
        label_bluetooth_status.setTextColor(Color.parseColor("#388e3c"))
        val device_name = if (connectedDevice.name != null) connectedDevice.name else "Unknown Device"
        Toast.makeText(this, "Connected to: $device_name", Toast.LENGTH_SHORT).show()
        label_bluetooth_status.text = device_name
    }

    override fun onCreateOptionsMenu(menu: Menu): Boolean {
        menuInflater.inflate(R.menu.app_menu, menu)
        return true
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        when (item.itemId) {
            R.id.app_menu_chat -> {
                Log.d(TAG, "Clicked on Message Log")
                dialogMessageLog()
            }
            R.id.app_menu_search_device -> {
                Log.d(TAG, "Clicked on Search Device")
                dialogDevices()
            }
            R.id.app_menu_disconnect_device -> {
                Log.d(TAG, "Clicked on Disconnect Device")
                disconnectBluetoothDevice()
            }
            R.id.app_menu_reconnect_device -> {
                Log.d("BT-Main", "Clicked on Reconnect Device")
                dialogPairedDevices()
            }
            R.id.app_menu_string_config -> {
                Log.d(TAG, "Clicked on String Configurations")
                dialogConfigString()
            }
            else -> Log.d(TAG, "Clicked on default case")
        }
        return super.onOptionsItemSelected(item)
    }

    private fun disconnectedState() {
        label_bluetooth_status.text = "Not Connected"
        label_bluetooth_status.setTextColor(Color.parseColor("#d32f2f"))
        Toast.makeText(this, "Disconnected from device", Toast.LENGTH_SHORT).show()
    }
    private fun disableElement(view: View?) {
        view?.isEnabled = false
        view?.alpha = 0.7f
    }

    private fun enableElement(view: View?) {
        view?.isEnabled = true
        view?.alpha = 1f
    }

    private fun updateRobotPositionLabel() {
        label_origin_coordinateX.text = MapDrawer.Robot_X.toString()
        label_origin_coordinateY.text = MapDrawer.getRobotInvertY().toString()
    }

    private fun updateWaypointLabel() {
        label_waypoint_coordinateX.text = MapDrawer.Way_Point_X.toString()
        label_waypoint_coordinateY.text = MapDrawer.getWayPointYInvert().toString()
    }

    // Dialog Builders
    private fun dialogConfigString() {
        // View configs
        val dialog = inflater.inflate(R.layout.dialog_string_configs, null)
        val dialogBuilder = AlertDialog.Builder(this).setView(dialog)

        // configure event listeners
        textboxString1 = dialog.findViewById(R.id.textbox_string1)
        textboxString2 = dialog.findViewById(R.id.textbox_string2)
        dialog.findViewById<Button>(R.id.button_send_string1).setOnClickListener(sendString1)
        dialog.findViewById<Button>(R.id.button_send_string2).setOnClickListener(sendString2)
        dialog.findViewById<Button>(R.id.button_save_string_config).setOnClickListener(saveStringConfig)

        dialogBuilder.create()
        dialogBuilder.show()
        setStringConfig(textboxString1, textboxString2)
    }
    private fun dialogMessageLog() {
        // View configs
        val dialog = inflater.inflate(R.layout.dialog_message, null)
        val dialogBuilder = AlertDialog.Builder(this).setView(dialog)

        dialog.findViewById<Button>(R.id.button_send_message).setOnClickListener(sendMessage)
        textboxSendMessage = dialog.findViewById(R.id.textbox_send_message)
        scrollView = dialog.findViewById(R.id.msg_scroll_view)
        messageLogView = dialog.findViewById(R.id.message_log)
        messageLogView?.movementMethod = ScrollingMovementMethod()
        messageLogView?.text = messageLog.getLog()
        messageLogView?.setTextIsSelectable(true)
        scrollView?.post { Log.d(TAG, "Attempting to full scroll down"); scrollView?.fullScroll(ScrollView.FOCUS_DOWN) }
        dialogBuilder.show()
    }
    private fun dialogDevices() {
        // View configs
        val dialog = inflater.inflate(R.layout.dialog_devices, null)
        val dialogBuilder = AlertDialog.Builder(this).setView(dialog)
        listviewDevices = dialog.findViewById<View>(R.id.listView_devices) as ListView
        val adapter = DeviceAdapter(applicationContext, deviceList)
        listviewDevices.adapter = adapter
//        buttonBluetoothServerListen = dialog.findViewById(R.id.button_bluetooth_server_listen)
        buttonScan = dialog.findViewById(R.id.button_scan)

        if (connectionThread != null) {
            disableElement(listviewDevices)
            disableElement(buttonScan)
        }
        dialog.findViewById<Button>(R.id.button_scan).setOnClickListener(scanDevice)
        listviewDevices.onItemClickListener = connectDevice

        isPairedDevicesOnly = false
        dialogBuilder.show()
    }
    private var isPairedDevicesOnly = false
    private fun dialogPairedDevices() {
        val dialog = inflater.inflate(R.layout.dialog_devices, null)
        val dialogBuilder = AlertDialog.Builder(this).setView(dialog)
        listviewDevices = dialog.findViewById(R.id.listView_devices)
        val pairedDevices = bluetoothAdapter.bondedDevices
        pairedDevices.forEach { addDevice(it, it.name, it.address) }
        val adapter = DeviceAdapter(applicationContext, deviceList)
        listviewDevices.adapter = adapter
        dialog.findViewById<TextView>(R.id.btconn_instructions).text = "Make sure device is nearby before using this feature. Also disconnect current connections"
        dialog.findViewById<TextView>(R.id.label_dialog_bluetooth_title).text = "Reconnect Bluetooth Connection"
        dialog.findViewById<Button>(R.id.button_scan).visibility = View.GONE

        if (connectionThread != null) {
            disableElement(listviewDevices)
        }
        listviewDevices.onItemClickListener = connectDevice
        isPairedDevicesOnly = true
        dialogBuilder.show()
    }
    private val directionLeft = View.OnClickListener {
        sendString(commandWrap(Cmd.DIRECTION_LEFT))
        MapDrawer.moveLeft()
        canvas_gridmap.invalidate()
        updateRobotPositionLabel()
    }
    private val directionRight = View.OnClickListener {
        sendString(commandWrap(Cmd.DIRECTION_RIGHT))
        MapDrawer.moveRight()
        canvas_gridmap.invalidate()
        updateRobotPositionLabel()
    }
    private val directionUp = View.OnClickListener {
        val xAxis = MapDrawer.Robot_X
        val yAxis = MapDrawer.Robot_Y

        MapDrawer.moveUp()
        if (!(xAxis == MapDrawer.Robot_X && yAxis == MapDrawer.Robot_Y)) sendString(commandWrap(Cmd.DIRECTION_UP))
        canvas_gridmap.invalidate()
        updateRobotPositionLabel()
    }
    private val startMode = View.OnClickListener {
        if (startModeState) {
            startModeState = false
            button_start_phase.text = "Start"
            sendString(commandWrap(Cmd.SP))
            timer.cancel()
        } else {
            startModeState = true
            button_start_phase.text = "Stop"
            if (fastestPathModeState) sendString(commandWrap(Cmd.FASTEST_PATH_START))
            else sendString(commandWrap(Cmd.EXPLORATION_START))

            timer = object: CountDownTimer(30000000, 1000) {
                override fun onTick(l: Long) {
                    val timePassed = 30000000 - l
                    var seconds = timePassed / 1000
                    val minutes = seconds / 60
                    if (seconds == 355.toLong()){
                        sendString(commandWrap(Cmd.SP))
                    }
                    seconds %= 60
                    val timeFormatter = DecimalFormat("00")
                    val time = "${timeFormatter.format(minutes)} m ${timeFormatter.format(seconds)} s"
                    label_time_elapsed.text = time
                }
                override fun onFinish() { }
            }.start()
        }
    }
    private val setOrigin = View.OnClickListener {
        if (!MapDrawer.selectStartPoint && !MapDrawer.selectWayPoint) {
            button_set_origin.text = "Confirm Origin"
            disableElement(button_set_waypoint)
            disableElement(button_direction_left)
            disableElement(button_direction_right)
            disableElement(button_direction_up)
            sensorOrientation.disable()
            switch_motion_control.isChecked = false
            disableElement(switch_motion_control)
            disableElement(button_start_phase)
            disableElement(button_reset_map)
            MapDrawer.setSelectStartPoint()
            canvas_gridmap.invalidate()
        } else if (MapDrawer.selectStartPoint) {
            button_set_origin.text = "Set Origin"
            enableElement(button_set_waypoint)
            enableElement(button_direction_left)
            enableElement(button_direction_right)
            enableElement(button_direction_up)
            enableElement(switch_motion_control)
            enableElement(button_start_phase)
            enableElement(button_reset_map)
            val msg = "PC," +
                    "OG,[${MapDrawer.Robot_X},${MapDrawer.invertYAxis(MapDrawer.Robot_Y)},${MapDrawer.getRotationDir()}]"
            sendString(commandWrap(msg))
            MapDrawer.setSelectStartPoint()
            MapDrawer.updateStartPoint()
            canvas_gridmap.invalidate()
        }
    }
    private val setWayPoint = View.OnClickListener {
        if (!MapDrawer.selectStartPoint && !MapDrawer.selectWayPoint) {
            button_set_waypoint.text = "Confirm Waypoint"
            disableElement(button_set_origin)
            disableElement(button_direction_left)
            disableElement(button_direction_right)
            disableElement(button_direction_up)
            sensorOrientation.disable()
            switch_motion_control.isChecked = false
            disableElement(switch_motion_control)
            disableElement(button_start_phase)
            disableElement(button_reset_map)
            MapDrawer.setSelectWayPoint()
            canvas_gridmap.invalidate()
        } else if (MapDrawer.selectWayPoint) {
            button_set_waypoint.text = "Set Waypoint"
            enableElement(button_set_origin)
            enableElement(button_direction_left)
            enableElement(button_direction_right)
            enableElement(button_direction_up)
            enableElement(switch_motion_control)
            enableElement(button_start_phase)
            enableElement(button_reset_map)
            val msg = "PC,WP|${MapDrawer.Way_Point_X}|${MapDrawer.getWayPointYInvert()}"
            sendString(commandWrap(msg))

            MapDrawer.setSelectWayPoint()
            canvas_gridmap.invalidate()
        }
    }
    private val motionControl = CompoundButton.OnCheckedChangeListener { _: CompoundButton?, b: Boolean ->
        if (b) {
//            sensorOrientation.enable()
            disableElement(button_direction_left)
            disableElement(button_direction_right)
            disableElement(button_direction_up)
            disableElement(joystickView)
        } else {
//            sensorOrientation.disable()
            enableElement(button_direction_left)
            enableElement(button_direction_right)
            enableElement(button_direction_up)
            enableElement(joystickView)
        }
    }
    private val setMap = View.OnTouchListener { _, motionEvent ->
        if (motionEvent != null) {
            if (motionEvent.action == MotionEvent.ACTION_DOWN && (MapDrawer.selectStartPoint || MapDrawer.selectWayPoint)) {
                val xAxis = (motionEvent.x / MapDrawer.gridDimensions).toInt()
                val yAxis = (motionEvent.y / MapDrawer.gridDimensions).toInt()

                if (MapDrawer.validMidpoint(xAxis, yAxis)) {
                    MapDrawer.updateSelection(xAxis, yAxis)
                    canvas_gridmap.invalidate()
                }
                updateRobotPositionLabel()
                updateWaypointLabel()
            }
        }
        false
    }
    private val refreshState = View.OnClickListener {
        canvas_gridmap.invalidate()
        updateRobotPositionLabel()
    }
    private val changeModeFastestPath = CompoundButton.OnCheckedChangeListener { _: CompoundButton?, b: Boolean ->
        if(b){
            enableElement(button_set_waypoint)
        }else{
            disableElement(button_set_waypoint)
        }
        fastestPathModeState = b
        label_time_elapsed.text = "00 m 00 s"
        Log.d(TAG, "Fastest Path Mode : $fastestPathModeState")
    }
    private val changeAutoMode = CompoundButton.OnCheckedChangeListener { _: CompoundButton?, b: Boolean ->
        autoModeState = b
        Log.d(TAG, "Auto Mode : $autoModeState")
    }
    private val resetMap = View.OnClickListener {
        val dialog = AlertDialog.Builder(this).apply {
            setTitle("Map Reset")
            setMessage("Do you want to reset the map?")
            setNegativeButton("YES") { dialogInterface,_ ->
                MapDrawer.resetMap()
                canvas_gridmap.invalidate()
                dialogInterface.dismiss()
                updateRobotPositionLabel()
                Parser.hexImage = ""
            }
            setPositiveButton("NO") { dialogInterface,_ -> dialogInterface.dismiss() }
        }.create()
        dialog.show()
    }
    private val sendSP = View.OnClickListener {
        sendString(commandWrap(Cmd.SP))
    }

    // Event Listeners for Dialog Builders
    private val sendString1 = View.OnClickListener {
        val data = textboxString1?.text.toString()
        Log.d(TAG, "Data Sent (String 1) : $data")
        sendString(data)
    }
    private val sendString2 = View.OnClickListener {
        val data = textboxString2?.text.toString()
        Log.d(TAG, "Data Sent (String 2) : $data")
        sendString(data)
    }
    private val saveStringConfig = View.OnClickListener { saveStringConfig(textboxString1, textboxString2) }
    private val sendMessage = View.OnClickListener {
        val data = textboxSendMessage?.text.toString()
        Log.d(TAG, "Message Sent : $data")
        messageLog.addMessage(MESSAGE_SENDER, data)
        messageLogView?.text = messageLog.getLog()
        scrollView?.post { Log.d(TAG, "Attempting to full scroll down"); scrollView?.fullScroll(ScrollView.FOCUS_DOWN) }
        sendString(data)
        textboxSendMessage?.setText("")
    }
    private val scanDevice = View.OnClickListener {
        if (buttonScan?.text == "Scan Devices") {
//            disableElement(buttonBluetoothServerListen)
            buttonScan?.text = "Stop Scan"
            bluetoothAdapter.startDiscovery()
            clearDeviceList()
        } else if (buttonScan?.text == "Stop Scan") {
//            enableElement(buttonBluetoothServerListen)
            buttonScan?.text = "Scan Devices"
            bluetoothAdapter.cancelDiscovery()
        }
    }
    private val connectDevice = AdapterView.OnItemClickListener { _, _, i, _ ->
        val item = deviceList[i]
        val device = item.device

        Log.d(TAG, "Connecting to " + device.name + " " + device.address)
        if (bluetoothAdapter.isDiscovering) bluetoothAdapter.cancelDiscovery()

        connectedDevice = device
        connectBluetoothDevice()
    }

    private fun disconnectBluetoothDevice() {
        connectionThread?.cancel()
        connectionThread = null
        disconnectedState()
        disconnectState = true
    }

    private fun connectBluetoothDevice() {
        connectionThread = BluetoothService(streamHandler)
        connectionThread?.connectDevice(connectedDevice)
    }

    private fun sendString(data: String) {
        if (connectionThread != null) connectionThread?.write(data)
        else notConnected()
    }

    private fun setStringConfig(field_1: EditText?, field_2: EditText?) {
        if (field_1 == null || field_2 == null) {
            Log.e(TAG, "Uninitialized field, exiting")
            return
        }
        val sharedPref = applicationContext.getSharedPreferences(Store.SHARED_PREFERENCE_KEY, Context.MODE_PRIVATE)

        sharedPref?.let {
            val string1 = it.getString(Store.STRING_1, "") ?: ""
            val string2 = it.getString(Store.STRING_2, "") ?: ""

            if (string1.isNotEmpty() && string2.isNotEmpty()) {
                Log.d(TAG, "Store : $string1")
                Log.d(TAG, "Store : $string2")
                field_1.setText(string1)
                field_2.setText(string2)
            }
        }
    }
    private fun saveStringConfig(field_1: EditText?, field_2: EditText?) {
        if (field_1 == null || field_2 == null) {
            Log.e(TAG, "Field not initialized, exiting")
            return
        }
        val sharedPref = applicationContext.getSharedPreferences(Store.SHARED_PREFERENCE_KEY, Context.MODE_PRIVATE)
        val editor = sharedPref.edit()

        editor.putString(Store.STRING_1, field_1.text.toString())
        editor.putString(Store.STRING_2, field_2.text.toString())
        editor.apply() // Not using commit as that is synchronous
        savedString()
    }
    private fun savedString() { Toast.makeText(applicationContext, "Strings have been saved", Toast.LENGTH_SHORT).show() }
    private fun notConnected() { Toast.makeText(applicationContext, "Not connected with any devices", Toast.LENGTH_SHORT).show() }
    private fun transmissionFail() { Toast.makeText(applicationContext, "Error sending message to device", Toast.LENGTH_SHORT).show() }
    private fun handleRotation(degree: Int) {
        Log.d(TAG, degree.toString())
        val time = System.currentTimeMillis()

        if (degree in 80..100 && (time - currentTime) >= 250) {
            MapDrawer.moveRight()
            sendString(commandWrap(Cmd.DIRECTION_RIGHT))
        } else if (degree in 260..280 && (time - currentTime) >= 100) {
            MapDrawer.moveLeft()
            sendString(commandWrap(Cmd.DIRECTION_LEFT))
        } else if (degree in 170..190 && (time - currentTime) >= 100) {
            MapDrawer.moveUp()
            sendString(commandWrap(Cmd.DIRECTION_UP))
        } else return
        updateRobotPositionLabel()
        canvas_gridmap.invalidate()
        currentTime = System.currentTimeMillis()
    }
    private fun handleAction(payload: String) {
        Log.e("Action", "Parsing $payload")
        if (payload.first().equals('g')){
            MapDrawer.resetMap()
            var fastestPathString = payload.removePrefix("g")
            for (i in 0..fastestPathString.length-1 step 3){
                var cmd = fastestPathString.get(i)
                Log.e(TAG, "fastest path command: " + cmd)
                when(cmd){
                    'f' -> {
                        Handler().postDelayed({
                            var count = fastestPathString.subSequence(i+1, i+3).toString().toInt()
                            for(j in 1..count){
                                val xAxis = MapDrawer.Robot_X
                                val yAxis = MapDrawer.Robot_Y
                                MapDrawer.moveUp()
                                canvas_gridmap.invalidate()
                                updateRobotPositionLabel()
                        }}, 300)
                    }
                    'r' ->{Handler().postDelayed(
                        {
                            MapDrawer.moveRight()
                            canvas_gridmap.invalidate()
                            updateRobotPositionLabel()
                        }, 300)
                    }
                    'l' ->{Handler().postDelayed(
                        {
                            MapDrawer.moveLeft()
                            canvas_gridmap.invalidate()
                            updateRobotPositionLabel()
                        }, 300)
                    }
                }
            }
        }else{
            parser.parse(payload)
            handleUpdatePosition(parser.robotX, parser.robotY, parser.robotDir)

            MapDrawer.setGrid(parser.exploredMap)
            updateRobotPositionLabel()
            if(parser.images.length() == 5){
                sendString(commandWrap(Cmd.SP))
            }
        }
    }

    private fun handleUpdatePosition(x_axis: Int, y_axis: Int, dir: String) {
        try {
            MapDrawer.updateCoordinates(x_axis, y_axis, dir)

            if (autoModeState) canvas_gridmap.invalidate()
        } catch (typeEx: ClassCastException) {
            Log.d(TAG, "Unable to cast data into int")
        }
        updateRobotPositionLabel()
    }

    private fun handleUpdateStatus(data: String) {
        Log.d(TAG, "Status Update : $data")
        label_status_details.text = data
    }

    private fun commandWrap(cmd: String): String {
        return "${cmd}"
    }

    companion object {
        private const val TAG = "Main"
        const val FROMANDROID = "\"from\":\"Android\","
    }
}